==========
How to ... 
==========

This module shows how to use the :class:`~radis.spectrum.spectrum.Spectrum` class, 
and the different methods that are associated: 
:meth:`~radis.spectrum.spectrum.Spectrum.rescale_path_length`,
:meth:`~radis.spectrum.spectrum.Spectrum.rescale_mole_fraction`, 
:meth:`~radis.spectrum.spectrum.Spectrum.apply_slit`, 
:meth:`~radis.spectrum.spectrum.Spectrum.store`, etc. 

initialize a Spectrum object?
-----------------------------

Spectrum objects are generated by the RADIS line-by-line module. They can 
also be generated from numpy arrays, or files. 

From numpy arrays, use :meth:`~radis.spectrum.spectrum.Spectrum.from_array` ::

    # w, T are two numpy arrays 
    from radis import Spectrum
    s = Spectrum.from_array(w, T, 'transmittance_noslit', 
                               waveunit='nm', unit='I/I0')
                               
              
From a file, use , use :meth:`~radis.spectrum.spectrum.Spectrum.from_txt` ::
                 
    # 'exp_spectrum.txt' contains a spectrum
    from radis import Spectrum
    s = Spectrum.from_txt('exp_spectrum.txt', 'radiance', 
                               waveunit='nm', unit='mW/cm2/sr/nm')

Convenience functions have been added to handle the usual cases: 
:func:`~radis.spectrum.spectrum.calculated_spectrum`, 
:func:`~radis.spectrum.spectrum.transmittance_spectrum` and
:func:`~radis.spectrum.spectrum.experimental_spectrum`::

    # w, T, I are numpy arrays for wavelength, transmittance and radiance
    from radis import calculated_spectrum, transmittance_spectrum, experimental_spectrum
    s1 = calculated_spectrum(w, I, wunit='nm', Iunit='W/cm2/sr/nm')     # creates 'radiance_noslit'  
    s2 = transmittance_spectrum(w, T, wunit='nm')                       # creates 'transmittance_noslit'
    s3 = experimental_spectrum(w, I, wunit='nm', Iunit='W/cm2/sr/nm')   # creates 'radiance'    
    
    
get spectral quantities?
------------------------

Spectral quantities (see the list of quantities in :doc:`spectrum`) can be stored under 
different formats in a Spectrum object (with wavenumbers, or wavelengths
in air, or wavelengths in vacuum, for a given unit, etc.) 

It is recommended to use the .get() method to get exactly what you want::
    
    w, I = s.get('transmittance_noslit', wunit='cm-1')  
    _, T = s.get('radiance_noslit', wunit='nm', Iunit='W/cm2/sr/nm',
                 medium='air')  
        
The default quantities are::

    # Convoluted with slit function:
    'radiance', 'transmittance', 'emissivity'
    
    # Not convoluted: 
    'radiance_noslit', 'transmittance_noslit', 'emisscoeff', 'absorbance', 
    'abscoeff', 'abscoeff_continuum', 'emissivity_noslit'
    
    
calculate missing quantities?
-----------------------------

Some spectral quantities can be infered from quantities stored in the Spectrum 
if enough conditions are given. For instance, transmittance can be recomputed
from the spectral absorption coefficient if the path length is stored in the 
conditions. 

The :meth:`~radis.spectrum.rescale.update` method can be used to do that. 
Example::

    # w, A are numpy arrays for wavenumber and absorption coefficient
    s = Spectrum.from_array(w, A, 'abscoeff', wunit='cm-1')
    s.update('transmittance_noslit')
    
Or, all derivable quantities can be computed using .update('all') or simply .update()::

    s.update() 
    

update Spectrum conditions?
---------------------------

Spectrum conditions are stored in a :attr:`~radis.spectrum.spectrum.Spectrum.conditions` dictionary 

Conditions can be updated *a posteriori* by modifying the dictionary::

    s.conditions['path_length'] = 10    # cm 


print Spectrum conditions?
--------------------------

Want to know under which calculation conditions was your Spectrum object 
generated, or under which experimental conditions it was measure? 
Just print it::

    print(s)
    
(that shows all spectral quantities stored in the object, all keys and 
values in the :attr:`~radis.spectrum.spectrum.Spectrum.conditions` dictionary, 
and all atoms/molecules stored in the :attr:`~radis.spectrum.spectrum.Spectrum.populations` 
dictionary)

You can also show the conditions only with 
:meth:`~radis.spectrum.spectrum.Spectrum.print_conditions`::

	s.print_conditions()
    
rescale Spectrum with new path length?
--------------------------------------

Path length can be changed after the spectra was calculated with the 
:meth:`~radis.spectrum.spectrum.Spectrum.rescale_path_length` method. 
If the spectrum is not optically thin, this requires to solve the radiative 
transfer equation again, so the emisscoeff and abscoeff quantities 
will have to be stored in the Spectrum, or any equivalent combination 
(radiance_noslit and absorbance, for instance). 

Example:

    >>> from radis import load_spec
    >>> s = load_spec('co_calculation.spec')
    >>> s.rescale_path_length(0.5)      # calculate for new path_length
    
    
rescale Spectrum with new mole fraction?
----------------------------------------

.. warning::

    Rescaling mole fractions neglects the changes in collisional broadening

mole fraction can also be changed in post-processing, using the 
:meth:`~radis.spectrum.spectrum.Spectrum.rescale_mole_fraction` method
that works similarly to the :meth:`~radis.spectrum.spectrum.Spectrum.rescale_path_length` 
method. However, the broadening coefficients are left unchanged, which is 
valid for small mole fraction changes. However, for large mole fraction changes 
you will have to recalculate the spectrum from scratch.    
    
    >>> s.rescale_mole_fraction(0.02)   # calculate for new mole fraction


apply instrumental slit function?
---------------------------------

Use :meth:`~radis.spectrum.spectrum.Spectrum.apply_slit`::

    s.apply_slit(1.5)    # nm 
    

plot the slit function that was applied?
----------------------------------------

Use :meth:`~radis.spectrum.spectrum.Spectrum.plot_slit`. You can also
change the unit::
    
    s.apply_slit(0.5, 'cm-1')    # for instance
    s.plot_slit('nm')


plot spectral quantities?
-------------------------

Use :meth:`~radis.spectrum.spectrum.Spectrum.plot`::

    s.plot('radiance_noslit')
    
    
plot populations?
-----------------

Use :meth:`~radis.spectrum.spectrum.Spectrum.plot_populations`::

    s.plot_populations('vib', nunit='cm-3')
    
    
save and retrieve a Spectrum object?
------------------------------------

To store use the :meth:`~radis.spectrum.spectrum.Spectrum.store` method. To retrieve 
use the :func:`~radis.tools.database.load_spec` function::
    
    # Store (s is a Spectrum object)
    s.store(temp_file_name, compress=True)
    
    # Retrieve
    from radis.tools import load_spec 
    s2 = load_spec(temp_file_name)
    s2.update()    # regenerate missing quantities 
    
    
compare two Spectrum objects?
-----------------------------

Use one of the predefined functions :func:`~radis.spectrum.compare.get_diff`, 
:func:`~radis.spectrum.compare.get_ratio`, :func:`~radis.spectrum.compare.get_distance`, 
:func:`~radis.spectrum.compare.get_residual` or the plot function 
:func:`~radis.spectrum.compare.plot_diff`::

    from radis.spectrum import plot_diff
    s1 = load_spec(temp_file_name)
    s2 = load_spec(temp_file_name2)
    plot_diff(s1, s2, 'radiance')


Generate a Blackbody (Planck) function object?
----------------------------------------------

In RADIS you can either use the :func:`~radis.phys.blackbody.planck` and
:func:`~radis.phys.blackbody.planck_wn` functions that generate Planck
radiation arrays for wavelength and wavenumber, respectively. 

Or, you can use the :func:`~radis.phys.blackbody.sPlanck` function that
returns a :class:`~radis.spectrum.spectrum.Spectrum` object, with all 
the associated methods (add in a line-of-sight, compare, etc.)

Example::
    
    s = sPlanck(wavelength_min=3000, wavelength_max=50000,
                T=288, eps=1)
    s.plot()


    
