==========
How to ... 
==========

This module shows how to use the :class:`~radis.spectrum.spectrum.Spectrum` class, 
and the different methods that are associated: 
:meth:`~radis.spectrum.spectrum.Spectrum.rescale_path_length`,
:meth:`~radis.spectrum.spectrum.Spectrum.rescale_mole_fraction`, 
:meth:`~radis.spectrum.spectrum.Spectrum.apply_slit`, 
:meth:`~radis.spectrum.spectrum.Spectrum.store`, etc. 

.. toctree::
   :maxdepth: 2
   
   howto

   
---------------------------------------------------------------------

   
initialize a Spectrum object?
-----------------------------

Spectrum objects are generated by the RADIS line-by-line module. They can 
also be generated from numpy arrays, or files. 

From numpy arrays, use :meth:`~radis.spectrum.spectrum.Spectrum.from_array` ::

    # w, T are two numpy arrays 
    from radis import Spectrum
    s = Spectrum.from_array(w, T, 'transmittance_noslit', 
                               waveunit='nm', unit='I/I0')
                               
              
From a file, use :meth:`~radis.spectrum.spectrum.Spectrum.from_txt` ::
                 
    # 'exp_spectrum.txt' contains a spectrum
    from radis import Spectrum
    s = Spectrum.from_txt('exp_spectrum.txt', 'radiance', 
                               waveunit='nm', unit='mW/cm2/sr/nm')

Convenience functions have been added to handle the usual cases: 
:func:`~radis.spectrum.spectrum.calculated_spectrum`, 
:func:`~radis.spectrum.spectrum.transmittance_spectrum` and
:func:`~radis.spectrum.spectrum.experimental_spectrum`::

    # w, T, I are numpy arrays for wavelength, transmittance and radiance
    from radis import calculated_spectrum, transmittance_spectrum, experimental_spectrum
    s1 = calculated_spectrum(w, I, wunit='nm', Iunit='W/cm2/sr/nm')     # creates 'radiance_noslit'  
    s2 = transmittance_spectrum(w, T, wunit='nm')                       # creates 'transmittance_noslit'
    s3 = experimental_spectrum(w, I, wunit='nm', Iunit='W/cm2/sr/nm')   # creates 'radiance'    
    
    
get spectral quantities?
------------------------

Spectral quantities (see the list of quantities in :doc:`spectrum`) can be stored under 
different formats in a Spectrum object (with wavenumbers, or wavelengths
in air, or wavelengths in vacuum, for a given unit, etc.) 

It is recommended to use the :meth:`~radis.spectrum.spectrum.Spectrum.get` method to get exactly what you want::
    
    w, I = s.get('transmittance_noslit', wunit='cm-1')  
    _, R = s.get('radiance_noslit', wunit='nm', Iunit='W/cm2/sr/nm',
                 medium='air')  
        
The default quantities are::

    # Convoluted with slit function:
    'radiance', 'transmittance', 'emissivity'
    
    # Not convoluted: 
    'radiance_noslit', 'transmittance_noslit', 'emisscoeff', 'absorbance', 
    'abscoeff', 'abscoeff_continuum', 'emissivity_noslit'

See the latest list in the CONVOLUTED_QUANTITIES and NON_CONVOLUTED_QUANTITIES defined 
`here <https://github.com/radis/radis/blob/master/radis/spectrum/rescale.py>`__.
    
get wavelength / wavenumber?
------------------------

Use the :meth:`~radis.spectrum.spectrum.Spectrum.get_wavelength` and
:meth:`~radis.spectrum.spectrum.Spectrum.get_wavenumber` methods::
    
    w_nm = s.get_wavelength()
    w_cm = s.get_wavenumber()
        
    
calculate missing quantities?
-----------------------------

Some spectral quantities can be infered from quantities stored in the Spectrum 
if enough conditions are given. For instance, transmittance can be recomputed
from the spectral absorption coefficient if the path length is stored in the 
conditions. 

The :meth:`~radis.spectrum.rescale.update` method can be used to do that. 
Example::

    # w, A are numpy arrays for wavenumber and absorption coefficient
    s = Spectrum.from_array(w, A, 'abscoeff', wunit='cm-1')
    s.update('transmittance_noslit')
    
Or, all derivable quantities can be computed using .update('all') or simply .update()::

    s.update() 
    

update Spectrum conditions?
---------------------------

Spectrum conditions are stored in a :attr:`~radis.spectrum.spectrum.Spectrum.conditions` dictionary 

Conditions can be updated *a posteriori* by modifying the dictionary::

    s.conditions['path_length'] = 10    # cm 


print Spectrum conditions?
--------------------------

Want to know under which calculation conditions was your Spectrum object 
generated, or under which experimental conditions it was measured? 
Just print it::

    print(s)
    
(that shows all spectral quantities stored in the object, all keys and 
values in the :attr:`~radis.spectrum.spectrum.Spectrum.conditions` dictionary, 
and all atoms/molecules stored in the :attr:`~radis.spectrum.spectrum.Spectrum.populations` 
dictionary)

You can also show the conditions only with 
:meth:`~radis.spectrum.spectrum.Spectrum.print_conditions`::

	s.print_conditions()
    
rescale Spectrum with new path length?
--------------------------------------

Path length can be changed after the spectra was calculated with the 
:meth:`~radis.spectrum.spectrum.Spectrum.rescale_path_length` method. 
If the spectrum is not optically thin, this requires to solve the radiative 
transfer equation again, so the emisscoeff and abscoeff quantities 
will have to be stored in the Spectrum, or any equivalent combination 
(radiance_noslit and absorbance, for instance). 

Example:

    >>> from radis import load_spec
    >>> s = load_spec('co_calculation.spec')
    >>> s.rescale_path_length(0.5)      # calculate for new path_length
    
    
rescale Spectrum with new mole fraction?
----------------------------------------

.. warning::

    Rescaling mole fractions neglects the changes in collisional broadening

mole fraction can also be changed in post-processing, using the 
:meth:`~radis.spectrum.spectrum.Spectrum.rescale_mole_fraction` method
that works similarly to the :meth:`~radis.spectrum.spectrum.Spectrum.rescale_path_length` 
method. However, the broadening coefficients are left unchanged, which is 
valid for small mole fraction changes. However, for large mole fraction changes 
you will have to recalculate the spectrum from scratch.    
    
    >>> s.rescale_mole_fraction(0.02)   # calculate for new mole fraction


apply instrumental slit function?
---------------------------------

Use :meth:`~radis.spectrum.spectrum.Spectrum.apply_slit`::

    s.apply_slit(1.5)    # nm 
    
By default, convoluted spectra are thinner than non convoluted spectra, to remove 
side effects. Use the ``mode=`` argument to change this behaviour. 


plot the slit function that was applied?
----------------------------------------

Use :meth:`~radis.spectrum.spectrum.Spectrum.plot_slit`. You can also
change the unit::
    
    s.apply_slit(0.5, 'cm-1')    # for instance
    s.plot_slit('nm')


plot spectral quantities?
-------------------------

Use :meth:`~radis.spectrum.spectrum.Spectrum.plot`::

    s.plot('radiance_noslit')
    
    
plot populations?
-----------------

Use :meth:`~radis.spectrum.spectrum.Spectrum.plot_populations`::

    s.plot_populations('vib', nunit='cm-3')
    
    
save and retrieve a Spectrum object?
------------------------------------

To store use the :meth:`~radis.spectrum.spectrum.Spectrum.store` method. To retrieve 
use the :func:`~radis.tools.database.load_spec` function::
    
    # s is a Spectrum object
    s.store('temp_file.spec')
    from radis import load_spec
    s2 = load_spec('temp_file.spec')
    assert s == s2  # compare both

The generated ``.spec`` file can be read (and edited) with any text editor. However, 
it may take a lot of space. If memory is important, you may use the ``compress=True`` 
argument which will remove redundant spectral quantities (for instance, transmittance
if you already know absorbance), and store the .spec file under binary format. Use
the :meth:`~radis.spectrum.spectrum.Spectrum.update` method to regenerate missing 
quantities::

    s.store('temp_file.spec', compress=True, if_exists_then='replace')
    s2 = load_spec('temp_file.spec')
    s2.update()    # regenerate missing quantities 
    
If many spectra are stored in a folder, it may be time to set up a 
:class:`~radis.tools.database.SpecDatabase` structure to easily see all 
Spectrum conditions and get Spectrum that suits specific parameters 


export to txt?
--------------

Saving to .txt in general isn't recommended as you will loose some information (for instance,
the conditions). You better use :meth:`~radis.spectrum.spectrum.Spectrum.store` and export 
to .spec [hidden .json] format. 

If you really need to export a given spectral quantity to txt file (for use in another software, 
for instance), you can use the :meth:`~radis.spectrum.spectrum.Spectrum.savetxt` method that 
will export a given spectral quantity.

Example::

    s.savetxt('radiance_W_cm2_sr_um.csv', 'radiance_noslit', wunit='nm', Iunit='W/cm2/sr/Âµm')


compare two Spectrum objects?
-----------------------------

You can compare two Spectrum objects using the :meth:`~radis.spectrum.spectrum.Spectrum.compare_with` 
method, or simply the ``==`` statement (which is essentially the same thing)::

    s1 == s2 
    >>> True/False 
    s1.compare_with(s2)
    >>> True/False 
    
However, :meth:`~radis.spectrum.spectrum.Spectrum.compare_with` allows more freedom 
regarding what quantities to compare. ``==`` will compare everything of two spectra, 
including input conditions, units under which spectral quantities are stored, 
populations of species if they were saved, etc. In many situations we may want 
to simply compare the spectra themselves, or even a particular quantity like 
*transmittance_noslit*. Use::

    s1.compare_with(s2, spectra_only=True)                    # compares all spectral quantities 
    s1.compare_with(s2, spectra_only='transmittance_noslit')  # compares transmittance only 
    
The aforementionned methods will return a boolean array (True/False). If you 
need the difference, or ratio, or distance, between your two spectra, or simply 
want to plot the difference, you can use one of the predefined functions 
:func:`~radis.spectrum.compare.get_diff`, :func:`~radis.spectrum.compare.get_ratio`, 
:func:`~radis.spectrum.compare.get_distance`, :func:`~radis.spectrum.compare.get_residual` 
or the plot function :func:`~radis.spectrum.compare.plot_diff`::

    from radis.spectrum import plot_diff
    s1 = load_spec(temp_file_name)
    s2 = load_spec(temp_file_name2)
    plot_diff(s1, s2, 'radiance')

These functions usually require that the spectra are calculated on the same spectral 
range. When comparing, let's say, a calculated spectrum with experimental data, 
you may want to interpolate: you can have a look at the :meth:`~radis.spectrum.spectrum.Spectrum.resample` 
method. 

generate a Blackbody (Planck) function object?
----------------------------------------------

In RADIS you can either use the :func:`~radis.phys.blackbody.planck` and
:func:`~radis.phys.blackbody.planck_wn` functions that generate Planck
radiation arrays for wavelength and wavenumber, respectively. 

Or, you can use the :func:`~radis.phys.blackbody.sPlanck` function that
returns a :class:`~radis.spectrum.spectrum.Spectrum` object, with all 
the associated methods (add in a line-of-sight, compare, etc.)

Example::
    
    s = sPlanck(wavelength_min=3000, wavelength_max=50000,
                T=288, eps=1)
    s.plot()


create a database of Spectrum objects?
--------------------------------------

Use the :class:`~radis.tools.database.SpecDatabase` class. It takes a 
folder as an argument, as can be used to see the properties and all 
:class:`~radis.spectrum.spectrum.Spectrum` objects within this folder 
with :meth:`~radis.tools.database.SpecDatabase.see`, and select 
the Spectrum that match a given set of conditions with 
:meth:`~radis.tools.database.SpecDatabase.get`, 
:meth:`~radis.tools.database.SpecDatabase.get_unique` and 
:meth:`~radis.tools.database.SpecDatabase.get_closest`

    
