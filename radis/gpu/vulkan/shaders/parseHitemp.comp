#version 450
#extension GL_EXT_scalar_block_layout : enable
#extension GL_EXT_shader_explicit_arithmetic_types : enable
precision highp float;

layout (local_size_x_id = 0, local_size_y_id = 1, local_size_z_id = 2 ) in;
layout(constant_id = 0) const int LINE_LENGTH = 161;

layout(std430, binding = 0) uniform initData{
    int N_lines;
} init_d;

struct InstanceData
{
   uint8_t mol[2];     //  2
   uint8_t iso[1];     //  3
   uint8_t v[12];      // 15
   uint8_t I[10];      // 25
   uint8_t _pad0[LINE_LENGTH]; //161
};

layout(std430, binding = 1) readonly buffer SSBO1 {
   InstanceData inarr[];  
};

layout(std430, binding = 2) writeonly buffer SSBO2 {
   float outarr[];
};

void main(){
	uint8_t zero = uint8_t(48);
	uint8_t minus = uint8_t(45);

	uint k = gl_GlobalInvocationID.x;
    if (k > init_d.N_lines) return;
        
	InstanceData data = inarr[k];
    
    int res1, res2, res3;
    
////////////////

    // read v:
	res1 = 0;
	for (int i=0; i<5; i++){
        res1 *= 10;
		res1 += int(data.v[i] == 32 ? 0 : data.v[i] - zero);
	}
	
	res2 = 0;
	for (int i=6; i<12; i++){
        res2 *= 10;
		res2 += int(data.v[i] - zero);
	}
    
	outarr[2*k] = float(res1) + float(res2)*1e-6;
    
/////////////////

    // read I:
    res1 = 0;
	for (int i=0; i<2; i++){
        res1 *= 10;
		res1 += int(data.I[i] == 32 ? 0 : data.I[i] - zero);
	}
	
	res2 = 0;
	for (int i=3; i<6; i++){
        res2 *= 10;
		res2 += int(data.I[i] - zero);
	}
    
    res3 = 0;
	for (int i=8; i<10; i++){
        res3 *= 10;
		res3 += int(data.I[i] - zero);
	}
    res3 *= (data.I[7] == minus ? -1 : 1);
    
	outarr[2*k+1] = (float(res1) + float(res2)*1e-3) * pow(10., float(res3));

//////////////////
    
}

